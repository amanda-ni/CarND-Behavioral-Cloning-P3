import cv2
import csv
import numpy as np
import sklearn

import sys
import os.path
def check_file(filename):
    if not os.path.isfile(filename[0]):
        print("ERROR: File {} does not exist.".format(filename[0]))
        sys.exit(0)

# Get the manifest of image filenames
def get_manifest(filename):
    '''
    Return a list that contains all the filenames and labels
    Input:
        - filename (name of the *.csv file generated by the simulator)
    
    Output:
        - list of all the samples
    '''
    samples = []
    with open(filename) as csvfile:
        reader = csv.reader(csvfile)
        for line in reader:
            check_file(line)
            samples.append(line)
    # Omit the first line as it has no data
    return samples[1:]

# Data augmentation and/or selection
def random_augment(batch_sample, flip_prob=0.5, lcr_prob=None):
    '''
    Data augmentation and/or selection

    Input:
      - batch_sample: This is the line in the CSV file that has
                      the images (left, center, right), and the
                      truth data (angle, acceleration, etc.)
      - flip_prob: This is the probability that we'll flip the image.
                   The default setting is 0.5.
      - lcr_prob: This is the probability of choosing any one of
                  the three cameras.
                  Default is None, meaning uniformly picking.

    Output:
      - image: The augmented image
      - angle: the driving angle (-0.15 for right camera, +0.15 for
               left camera)
    '''

    # Choose the camera type
    choice = np.random.choice(3, lcr_prob)
    name = batch_sample[choice].strip()

    # Read the image and add offset to direction 
    image = cv2.imread(name)
    angle = float(batch_sample[3])+[0.0,0.25,-.25][choice]

    # Flip image
    if np.random.binomial(1,flip_prob):
        image = np.fliplr(image)
        angle = -angle

    return image, angle

# Generator to feed the neural network
def generator(samples, batch_size=32, flip_prob=0.15, lcr_prob=None):
    '''
    To avoid having to load in all the images, I created a
    generator as taught in class.

    Input:
      - samples: The manifest generated by get_manifest

    Output:
      - Next batch of images and angles
    '''
    num_samples = len(samples)
    while 1: # Loop forever so the generator never terminates
        sklearn.utils.shuffle(samples)
        for offset in range(0, num_samples, batch_size):
            batch_samples = samples[offset:offset+batch_size]
            images = []
            angles = []
            for batch_sample in batch_samples:
                image, angle = random_augment(batch_sample, flip_prob=flip_prob, lcr_prob=lcr_prob)
                images.append(image)
                angles.append(angle)

            # trim image to only see section with road
            X_train = np.array(images)
            y_train = np.array(angles)
            yield sklearn.utils.shuffle(X_train, y_train)

